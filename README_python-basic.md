# lab1

Задача 1: Получаем на вход строку, приводим её к нижнему регистру и перебираем поэлементно, если встреченный элемент находится в списке, состоящем из гласных букв, увеличиваем счётчик на единицу. По окончании возвращаем значение счётчика.

Задача 2: Получаем на вход строку и преобразуем её в множество. Множество - тип данных, который хранит только уникальные значения. Проверяем: если длина строки равна длине множества из неё, значит полученная строка состоит из уникальных символов, возвращаем True, в противном случае - False.

Задача 3: Получаем на вход положительное число и преобразуем ее в двоичное с помощью функции bin(). В полученной строке считаем количество единиц - это и есть количество бит равных 1 в данном числе.

Задача 4: Получаеем на вход положительное число. Проверяем: если при делении нацело на 10 оно возвращает 0, значит число состоит из 1 цифры и возвращаем 0. Иначе заводим счетчик и строковое представление числа. Пока длина строки больше 1 (то есть пока число не состоит из одной цифры), в новую переменную кладем результат произведения цифр предыдущего числа, а счетчик увеличиваем на единицу спустя одну такую операцию, а переменную строки меняем на строковое представление результата произведения цифр предыдущего числа.

Задача 5: Получаем на вход 2 целочисленных вектора одинаковой длины. Заведем переменную, которая будет хранить сумму квадратов разности между элементами векторов. Для одновременной итерации по обоим векторам используем функцию zip(), и вычисляемый квадрат разности будем прибавлять в ранее инициализированную переменную. Далее находим среднее значение, поделив полученную сумму на количество элементов в векторах, и само среднеквадратическое отклонение посредством заведения под знак корня (в нашем случае - возведение в степень 0.5)

Задача 6: Получаем на вход целое положительное число. Инициализируем переменную, в которой будет делитель, и список, где будут храниться все простые делители данного числа. Проверяем делители до корня данного числа, так как простых делителей больших корня числа не может быть. Если число делится на делитель без остатка, то добавляем делитель в список, а переменную с числом обновляем значением частного, иначе увеличиваем делитель на единицу для проверки следующих делителей. В конце цикла проверяем: если после всех операций число осталось больше единицы, значит оно само является простым, так как не нашлось простых делителей меньше его корня, и лобавляем его в список. Заводим еще 2 списка: в первом будут простые делители без повторений (получаем при помощи set() и сортируем), во втором - то, сколько раз встретился каждый из них: это будет степенью делителей. Инициализируем переменную, в которой будем хранить ответ. Одновременно итерируем по спискам с делителями и их степенями: если степень равна 1, то записываем лишь сам делитель, иначе строку вида (n**m).

Задача 7: Получаем на вход целое число. Инициализируем 2 переменные: в одной будем хранить некое число, начиная от единицы, во втором сумму его квадратов. Пока переменная с суммой меньше нашего заданного числа, переменную с числом увеличиваем на единицу, а переменную с суммой на его квадрат, соответственно. Если после выхода из цикла получившаяся сумма равна нашему числу, то пирамиду построить можно и возвращаем получившееся число, иначе - это невозможно и выводим "It's impossible"

Задача 8: Получаем на вход положительное число. Находим длину строкового представления данного числа, если она четная, то в переменные r,l кладем половинки строк изначально данного числа, иначе - половинки строк без учета среднего элемента. С помощью функции map() преобразуем полученные значения в последовательность цифр и найдем их сумму. В конце проверяем их на равенство
