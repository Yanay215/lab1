Задача 1: Сделаем генератор, внутри которого будет произведение элементов матрицы на элементы вектора с помощью метода dot() библиотеки numpy при одновременной итерации по матрице и вектору с помощью функции zip(). Вернем сумму элементов внутри генератора.

Задача 2: Сделаем генератор списка, внутри которого будет 1 если данный элемент больше условного threshold, а иначе 0 при итерации во вложенных циклах for по элементам строк матрицы. Далее преобразовываем результат в массив numpy с помощью метода array() и приводим его в вид матрицы при помощи метода reshape(), где первый аргумент - количество строк, а второй - количество столбцов.

Задача 3: Создадим список result, в котором будут уникальные элементы каждой строки. Итерируем по строкам матрицы: для выявления уникальных элементов приведем её к типу "множество", после чего обратно к типу "список" и расширяем наш result при помощи метода extend. Возвращаем отсортированный список при помощи функции sorted(). В случае с колонками почти та же история: только в начале транспонируем матрицу методом transpose() чтобы столбцы стали строками и по ним было удобнее итерировать. При приведении к типу множество не забываем сначала привести к типу "список", так как после транспонирования у строк теперь тип "numpy array".

Задача 4: Создадим матрицу с данными размерами, в которых будут случайные числа распределенные по нормальному закону. Для этого воспользуемся методом normal модуля random библиотеки numpy, которая на вход принимает среднее распределения (по умолчанию 0), стандартное отклонение (по умолчанию 1), и кортеж с нашими числами. Инициализируем 2 списка, в первом из которых будем хранить математическое ожидание, во втором - дисперсию. Итерируем вначале по строкам получившейся матрицы и считаем мат. ожидание с помощью метода mean(), а дисперсию с помощью метода var() и добавляем их в списки. Для построения гистограммы значений каждой строки воспользуемся методом hist() модуля pyplot библиотеки matplotlib и покажем с помощью метода show(). Для столбцов абсолютно та же история, только перед этим транспонируем матрицу по уже знакомому нам методу transpose(). В конце выводим полученные списки с мат. ожиданиями и дисперсиями.

Задача 5: Создадим матрицу данных нам размеров, заполненную нулями с помощью метода zeros(). Используя срезы будем заполнять нашу матрицу данными нам значениями. Переменная a будет лежать во всех четных и нечетных индексах по строкам и столбцам ( (0,0) , (2,2) и т.д. ; (1,1) , (3,3) и т.д. ), в то время как переменная b будет лежать во всех строках с нечетными индексами, но в столбцах с четными ( (1,0) , (3,2) и т.д. ), и наоборот - во всех строках с четными индексами, но в стобцах с нечетными ( (0,1) , (2,3) и т.д. ). Срезы: [m:n:k] - где m - начало, n - конец, k - шаг. Если не заполнено первое значение, то оно автоматически будет считать от начала, т.е. от 0, а если не заполнено второе значение, то автоматически будет идти до конца списка, а если не заполнен шаг, то он будет равен 1. В нашем случае у нас везде шаг 2, что позволяет нам чередовать эти значения между собой и получить шахматный порядок.

Задача 6: 
1) Прямоугольник. Создадим трехмерный массив numpy заполненный единицами и умножим его на массив цвета заднего фона. Визуально, изображение - это сетка пикселей, и методом ones() мы создали массив высотой m, шириной n, и 3 цветами (RGB). Заполнив всё единицами, мы дали изображению условный белый цвет ([1,1,1]), но умножив это значение на цвет заднего фона оно станет другим. С помощью срезов отмечаем размеры прямоугольника и присваиваем этим областям цвет прямоугольника ([:a,:b], где a - длина, b - ширина). Он нарисуется начиная с верхнего левого угла, далее осталось только отобразить с помощью метода imshow() и показать с помощью метода show() уже знакомой нам библиотеки Matplotlib
2) Эллипс. Создадим координатную сетку с помощью метода ogrid() размерами m, n - x - по горизонтали, y - по вертикали, соответственно. В переменную equation запишем уравнение эллипса, сама же фигура есть множество точек для которых это уравнение не больше единицы. По уже знакомому нам методу ones() создаем изображение, красим его в цвет фона, и с помощью условия эллипса в индексе раскрашиваем его данным нам цветом. Далее, как и с прямоугольником, отображаем и показываем получившееся изображение.

Задача 7: Получаем на вход временной ряд и уже по знакомым методам находим мат. ожидание и дисперсию и с помощью метода std() находим СКО, кладем их в переменные mean, var, std соответственно. Для нахождения локальных максимумов и минимумов воспользуемся генераторами, но перед этим разберемся как их искать. Точка является точкой локального максимума, если при переходу через эту точку первая производная функции меняет знак с "+" на "-", и наоборот: точка минимума - если с "-" на "+". То есть для начала находим разности между последовательными элементами списка с помощью метода diff() (возвращает список где: out[i] = in[i+1] - in[i]). Для избежания выхода за границы массива используем метод append() и добавим значение nan из самой библиотеки numpy. Далее находим знаки с помощью метода sign() (возвращает 1, если i>0, -1 - i<0, 0 - i=0). Далее еще раз используем diff(), и те значения которые отрицательные и есть те, которые были локальными максимумами. Добавляем nan, чтобы не возникало путаницы с индексами и с помощью метода where() ищем индексы отрицательных значений. С помощью индексации берем первый элемент, т.к. этот метод возвращает кортеж из нескольких элементов для каждого измерения, отнимаем единицу, чтобы индекс сошелся с изначальным, поскольку мы добавили nan, то индекс сместился. Далее в генераторе отбираем только те элементы индексы которых содержатся в полученном списке. Для локальных минимумов та же история, только вместо отрицательных будут положительные. Далее находим скользящее среднее по окну p методом convolve. Выполняем свертку временного ряда по окну p (создается массив состоящий из единиц размера р и делится на р - окно), аргумент mode приравниваем к 'valid', что значит выполнять свертку только для тех позиций, где возможно полностью наложить окно (массив р на массив t). В конце просто возвращаем список из всех вычисленных значений.

Задача 8: Для начала создаем двумерный массив для хранения получаемых векторов. С помощью zeros() создаем матрицу заполненную нулями, строк будет столько сколько изначально была длина вектора, а столбцов - максимальный_элемент+1, так как индексация начинается с 0. Далее с помощью arange() создаем последовательность индексов строк, где должны будут размещаться единицы, значения самого вектора на входе будут индексами для столбцов. Используя эту индексацию для нашей результирующей матрицы, преобразуем соответствующие элементы в 1 и возвращаем результат.
